) +
annotate(
geom = "label",
x = min(df2$x[df2$resp == "lower"]),
y = max(df2$y[df2$resp == "lower"]),
hjust = 0, vjust = 1.5,
size = 5,
label = paste0(
"RT distribution for incorrect responses (",
(n_incorrect / 1e3) * 100, "% of trials)"
)
) +
# aesthetics
theme_ipsum_rc(base_size = 12, axis_title_size = 12) +
theme(
axis.text.y = element_blank(),
plot.margin = unit(c(1, 1, 1, 3), "cm")
) +
labs(x = "Reaction time (in seconds)", y = "") +
coord_cartesian(xlim = c(0, NA), clip = "off")
rsconnect::deployApp(appName = "shiny_DDM")
shinyApp(ui, server)
runApp('app_example.R')
install.packages("pBrackets")
library(pBrackets)
nobs = 1e3; alpha = 2; beta = 0.5; delta = 0.5; tau = 0.8;
df <- rwiener(n = nobs, alpha = alpha, tau = tau, beta = beta, delta = delta)
# generates some data using the RWiener package
df <- rwiener(
n = 1e3,
alpha = alpha,
beta = beta,
delta = delta,
tau = tau
)
library(shinythemes)
library(shinyhelper)
library(hrbrthemes)
library(tidyverse)
library(pBrackets)
library(RWiener)
library(shiny)
nobs = 1e3; alpha = 2; beta = 0.5; delta = 0.5; tau = 0.8;
df <- rwiener(n = nobs, alpha = alpha, tau = tau, beta = beta, delta = delta)
# computes the number of correct and incorrect responses
correct_table <- table(df$resp) %>% data.frame
n_correct <- correct_table %>%
filter(Var1 == "upper") %>%
pull(Freq) %>%
as.numeric
n_incorrect <- correct_table %>%
filter(Var1 == "lower") %>%
pull(Freq) %>%
as.numeric
# computes densities
ud <- density(df$q[df$resp == "upper"], cut = 0)
ld <- density(df$q[df$resp == "lower"], cut = 0)
# rescales alpha between 0.5 and 1 to define the
# vertical blank space between densities
s <- (alpha / 10) * (1 - 0.5) + 0.5
# horizontal position of the densities
x <- c(ud$x[1], ud$x, ud$x[length(ud$x)], ld$x[1], ld$x, ld$x[length(ld$x)])
# vertical position of the densities
y <- c(s, ud$y + s, s, -s, -ld$y - s, -s)
# standardised starting point (relative to the standardised alpha)
lower_limit <- 0 - s / 2
upper_limit <- 0 + s / 2
beta_s <- lower_limit + beta * s
# computes the implied angle of the drift rate
drift_angle <- atan(delta) * 180 / pi
# new data frame
df2 <- data.frame(
x = x, y = y,
resp = rep(c("upper", "lower"), each =  length(ud$x) + 2)
)
df2 %>%
ggplot(aes(x = x, y = y, fill = resp, color = resp) ) +
# plotting densities
geom_segment(
data = . %>% filter(resp == "upper"),
aes(x = 0, xend = max_x, y = min(y), yend = min(y) ),
color = upper_color
) +
geom_segment(
data = . %>% filter(resp == "lower"),
aes(x = 0, xend = max_x, y = max(y), yend = max(y) ),
color = lower_color
) +
geom_polygon(alpha = 0.8) +
scale_fill_manual(
values = c(lower_color, upper_color),
guide = guide_none()
) +
scale_color_manual(
values = c(lower_color, upper_color),
guide = guide_none()
) +
# stimulus onset
geom_vline(xintercept = 0, lty = 2, col = "grey30") +
annotate(
geom = "text",
x = 0, y = max(y),
hjust = 1,
vjust = -1,
size = 5, angle = 90,
label = "stimulus onset",
color = "grey30"
) +
# starting point
geom_hline(yintercept = beta_s, lty = 3, col = "purple") +
annotate(
geom = "label",
x = 0, y = beta_s,
hjust = 1,
vjust = 0.5,
size = 5,
label = "starting point",
colour = "purple"
) +
# non-decision time
annotate(
geom = "rect",
xmin = 0, xmax = tau,
ymin = -Inf, ymax = Inf,
alpha = 0.25
) +
# drift rate
# geom_segment(
#     aes(
#         x = tau,
#         # xend = tau + 0.1,
#         xend = tau + 0.1 * max_x,
#         y = beta_s,
#         # yend = log(delta / (1 - beta) ) + delta / 2
#         # yend = beta_s + delta
#         yend = ifelse(beta_s + delta > s, s, beta_s + delta)
#         ),
#     arrow = arrow(
#         length = unit(0.2, "cm"),
#         ends = "last", type = "closed"
#         ),
#     size = 0.5, colour = "darkgreen"
#     ) +
geom_spoke(
aes(x = tau, y = beta_s, angle = drift_angle * (pi / 180), radius = 0.5),
arrow = arrow(length = unit(0.2, "cm"), ends = "last", type = "closed"),
color  = "darkgreen"
) +
annotate(
geom = "label",
x = tau,
y = beta_s,
hjust = 1, vjust = 0.5,
size = 5,
label = "drift rate",
color = "darkgreen"
) +
# boundary separation
geom_segment(
aes(
x = mean(x), xend = mean(x),
y = -s, yend = s,
),
arrow = arrow(
length = unit(0.2, "cm"),
ends = "both", type = "closed"
),
size = 0.5, colour = "black"
) +
annotate(
geom = "label",
x = mean(x), y = 0,
hjust = 0.5, vjust = 0.5,
size = 5,
label = "boundary separation",
color = "black"
) +
# labelling distributions
annotate(
geom = "label",
x = min(df2$x[df2$resp == "upper"]),
y = min(df2$y[df2$resp == "upper"]),
hjust = 0, vjust = -0.5,
size = 5,
label = paste0(
"RT distribution for correct responses (",
(n_correct / 1e3) * 100, "% of trials)"
)
) +
annotate(
geom = "label",
x = min(df2$x[df2$resp == "lower"]),
y = max(df2$y[df2$resp == "lower"]),
hjust = 0, vjust = 1.5,
size = 5,
label = paste0(
"RT distribution for incorrect responses (",
(n_incorrect / 1e3) * 100, "% of trials)"
)
) +
# aesthetics
theme_ipsum_rc(base_size = 12, axis_title_size = 12) +
theme(
axis.text.y = element_blank(),
plot.margin = unit(c(1, 1, 1, 3), "cm")
) +
labs(x = "Reaction time (in seconds)", y = "") +
coord_cartesian(xlim = c(0, NA), clip = "off")
# defines colors for lower and upper densities
lower_color <- "#c72e29"
upper_color <- "#016392"
df2 %>%
ggplot(aes(x = x, y = y, fill = resp, color = resp) ) +
# plotting densities
geom_segment(
data = . %>% filter(resp == "upper"),
aes(x = 0, xend = max_x, y = min(y), yend = min(y) ),
color = upper_color
) +
geom_segment(
data = . %>% filter(resp == "lower"),
aes(x = 0, xend = max_x, y = max(y), yend = max(y) ),
color = lower_color
) +
geom_polygon(alpha = 0.8) +
scale_fill_manual(
values = c(lower_color, upper_color),
guide = guide_none()
) +
scale_color_manual(
values = c(lower_color, upper_color),
guide = guide_none()
) +
# stimulus onset
geom_vline(xintercept = 0, lty = 2, col = "grey30") +
annotate(
geom = "text",
x = 0, y = max(y),
hjust = 1,
vjust = -1,
size = 5, angle = 90,
label = "stimulus onset",
color = "grey30"
) +
# starting point
geom_hline(yintercept = beta_s, lty = 3, col = "purple") +
annotate(
geom = "label",
x = 0, y = beta_s,
hjust = 1,
vjust = 0.5,
size = 5,
label = "starting point",
colour = "purple"
) +
# non-decision time
annotate(
geom = "rect",
xmin = 0, xmax = tau,
ymin = -Inf, ymax = Inf,
alpha = 0.25
) +
# drift rate
# geom_segment(
#     aes(
#         x = tau,
#         # xend = tau + 0.1,
#         xend = tau + 0.1 * max_x,
#         y = beta_s,
#         # yend = log(delta / (1 - beta) ) + delta / 2
#         # yend = beta_s + delta
#         yend = ifelse(beta_s + delta > s, s, beta_s + delta)
#         ),
#     arrow = arrow(
#         length = unit(0.2, "cm"),
#         ends = "last", type = "closed"
#         ),
#     size = 0.5, colour = "darkgreen"
#     ) +
geom_spoke(
aes(x = tau, y = beta_s, angle = drift_angle * (pi / 180), radius = 0.5),
arrow = arrow(length = unit(0.2, "cm"), ends = "last", type = "closed"),
color  = "darkgreen"
) +
annotate(
geom = "label",
x = tau,
y = beta_s,
hjust = 1, vjust = 0.5,
size = 5,
label = "drift rate",
color = "darkgreen"
) +
# boundary separation
geom_segment(
aes(
x = mean(x), xend = mean(x),
y = -s, yend = s,
),
arrow = arrow(
length = unit(0.2, "cm"),
ends = "both", type = "closed"
),
size = 0.5, colour = "black"
) +
annotate(
geom = "label",
x = mean(x), y = 0,
hjust = 0.5, vjust = 0.5,
size = 5,
label = "boundary separation",
color = "black"
) +
# labelling distributions
annotate(
geom = "label",
x = min(df2$x[df2$resp == "upper"]),
y = min(df2$y[df2$resp == "upper"]),
hjust = 0, vjust = -0.5,
size = 5,
label = paste0(
"RT distribution for correct responses (",
(n_correct / 1e3) * 100, "% of trials)"
)
) +
annotate(
geom = "label",
x = min(df2$x[df2$resp == "lower"]),
y = max(df2$y[df2$resp == "lower"]),
hjust = 0, vjust = 1.5,
size = 5,
label = paste0(
"RT distribution for incorrect responses (",
(n_incorrect / 1e3) * 100, "% of trials)"
)
) +
# aesthetics
theme_ipsum_rc(base_size = 12, axis_title_size = 12) +
theme(
axis.text.y = element_blank(),
plot.margin = unit(c(1, 1, 1, 3), "cm")
) +
labs(x = "Reaction time (in seconds)", y = "") +
coord_cartesian(xlim = c(0, NA), clip = "off")
# standardised starting point (relative to the standardised alpha)
lower_limit <- 0 - s / 2
upper_limit <- 0 + s / 2
beta_s <- lower_limit + beta * s
# computes the implied angle of the drift rate
drift_angle <- atan(delta) * 180 / pi
# new data frame
df2 <- data.frame(
x = x, y = y,
resp = rep(c("upper", "lower"), each =  length(ud$x) + 2)
)
# gets maximum x-axis value
max_x <- max(df2$x)
# defines colors for lower and upper densities
lower_color <- "#c72e29"
upper_color <- "#016392"
df2 %>%
ggplot(aes(x = x, y = y, fill = resp, color = resp) ) +
# plotting densities
geom_segment(
data = . %>% filter(resp == "upper"),
aes(x = 0, xend = max_x, y = min(y), yend = min(y) ),
color = upper_color
) +
geom_segment(
data = . %>% filter(resp == "lower"),
aes(x = 0, xend = max_x, y = max(y), yend = max(y) ),
color = lower_color
) +
geom_polygon(alpha = 0.8) +
scale_fill_manual(
values = c(lower_color, upper_color),
guide = guide_none()
) +
scale_color_manual(
values = c(lower_color, upper_color),
guide = guide_none()
) +
# stimulus onset
geom_vline(xintercept = 0, lty = 2, col = "grey30") +
annotate(
geom = "text",
x = 0, y = max(y),
hjust = 1,
vjust = -1,
size = 5, angle = 90,
label = "stimulus onset",
color = "grey30"
) +
# starting point
geom_hline(yintercept = beta_s, lty = 3, col = "purple") +
annotate(
geom = "label",
x = 0, y = beta_s,
hjust = 1,
vjust = 0.5,
size = 5,
label = "starting point",
colour = "purple"
) +
# non-decision time
annotate(
geom = "rect",
xmin = 0, xmax = tau,
ymin = -Inf, ymax = Inf,
alpha = 0.25
) +
# drift rate
# geom_segment(
#     aes(
#         x = tau,
#         # xend = tau + 0.1,
#         xend = tau + 0.1 * max_x,
#         y = beta_s,
#         # yend = log(delta / (1 - beta) ) + delta / 2
#         # yend = beta_s + delta
#         yend = ifelse(beta_s + delta > s, s, beta_s + delta)
#         ),
#     arrow = arrow(
#         length = unit(0.2, "cm"),
#         ends = "last", type = "closed"
#         ),
#     size = 0.5, colour = "darkgreen"
#     ) +
geom_spoke(
aes(x = tau, y = beta_s, angle = drift_angle * (pi / 180), radius = 0.5),
arrow = arrow(length = unit(0.2, "cm"), ends = "last", type = "closed"),
color  = "darkgreen"
) +
annotate(
geom = "label",
x = tau,
y = beta_s,
hjust = 1, vjust = 0.5,
size = 5,
label = "drift rate",
color = "darkgreen"
) +
# boundary separation
geom_segment(
aes(
x = mean(x), xend = mean(x),
y = -s, yend = s,
),
arrow = arrow(
length = unit(0.2, "cm"),
ends = "both", type = "closed"
),
size = 0.5, colour = "black"
) +
annotate(
geom = "label",
x = mean(x), y = 0,
hjust = 0.5, vjust = 0.5,
size = 5,
label = "boundary separation",
color = "black"
) +
# labelling distributions
annotate(
geom = "label",
x = min(df2$x[df2$resp == "upper"]),
y = min(df2$y[df2$resp == "upper"]),
hjust = 0, vjust = -0.5,
size = 5,
label = paste0(
"RT distribution for correct responses (",
(n_correct / 1e3) * 100, "% of trials)"
)
) +
annotate(
geom = "label",
x = min(df2$x[df2$resp == "lower"]),
y = max(df2$y[df2$resp == "lower"]),
hjust = 0, vjust = 1.5,
size = 5,
label = paste0(
"RT distribution for incorrect responses (",
(n_incorrect / 1e3) * 100, "% of trials)"
)
) +
# aesthetics
theme_ipsum_rc(base_size = 12, axis_title_size = 12) +
theme(
axis.text.y = element_blank(),
plot.margin = unit(c(1, 1, 1, 3), "cm")
) +
labs(x = "Reaction time (in seconds)", y = "") +
coord_cartesian(xlim = c(0, NA), clip = "off")
grid.locator(unit="native")
library(grid)
grid.locator(unit="native")
bottom_y <- 284
grid.brackets(220, bottom_y,   80, bottom_y, lwd=2, col="red")
grid.brackets(600, bottom_y,  440, bottom_y, lwd=2, col="red")
grid.locator(unit="native")
?grid.brackets
grid.brackets(x1 = 0, y1 = bottom_y, x2 = 220, bottom_y, lwd = 2, col = "red")
grid.brackets(x1 = 0, y1 = bottom_y, x2 = tau, y2 = bottom_y, lwd = 2, col = "red")
grid.brackets(x1 = 0, y1 = 1, x2 = tau, y2 = 1, lwd = 2, col = "red")
grid.brackets(x1 = 0, y1 = 0, x2 = tau, y2 = 1, lwd = 2, col = "red")
grid.brackets(x1 = 0, y1 = 0, x2 = 0 + tau, y2 = 1, lwd = 2, col = "red")
tau
grid.brackets(x1 = 0, y1 = 0, x2 = 0 + tau, y2 = 2, lwd = 2, col = "red")
grid.brackets(x1 = 0, y1 = 0, x2 = 0 + tau, y2 = 2, lwd = 2, col = "red")
grid.locator(unit="native")
grid.brackets(x1 = 0, y1 = 90, x2 = 0 + tau, y2 = 90, lwd = 2, col = "red")
grid.brackets(x1 = 0, y1 = 90, x2 = 0 + tau, y2 = 90, lwd = 2, col = "red")
